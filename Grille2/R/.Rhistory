style = "overflow-y: auto; max-height: 80vh; padding-bottom: 20px;",
tableOutput("takuzu_grid")  # ou ton équivalent
),
# Slider de difficulté
div(class = "difficulty-slider",
sliderInput("difficulty", "Difficulté",
min = 0.1, max = 0.8, value = 0.5, step = 0.1,
width = "80%")
)
)
)
)
# Serveur
server <- function(input, output, session) {
# État du jeu actuel
game_data <- reactiveVal(NULL)
# Taille actuelle de la grille (réactive)
grid_size <- reactive({
as.numeric(input$grid_size)
})
# Valeurs actuelles des cellules (réactives)
cell_values <- reactiveVal(NULL)
# Affichage de la taille actuelle
output$game_size_display <- renderUI({
size <- grid_size()
h3(paste0("Taille de la grille: ", size, "x", size))
})
# Aller à la page de sélection de taille
observeEvent(input$start_button, {
updateTextInput(session, "display_mode", value = "size_select")
})
# Aller à la page des règles
observeEvent(input$rules_button, {
updateTextInput(session, "display_mode", value = "rules")
})
# Retour à l'accueil depuis les règles
observeEvent(input$back_from_rules, {
updateTextInput(session, "display_mode", value = "home")
})
# Retour à l'accueil depuis la sélection de taille
observeEvent(input$back_from_size, {
updateTextInput(session, "display_mode", value = "home")
})
# Retour à l'accueil depuis le jeu
observeEvent(input$back_to_home, {
updateTextInput(session, "display_mode", value = "home")
})
# Aller à la page de changement de taille
observeEvent(input$change_size_btn, {
updateTextInput(session, "display_mode", value = "size_select")
})
# Sélection de la taille 6x6
observeEvent(input$select_size_6, {
updateTextInput(session, "grid_size", value = "6")
# Générer la grille initiale
game_data(generate_takuzu_grid(6, input$difficulty))
# Initialiser les valeurs des cellules
cell_values(game_data()$grid)
# Passer à l'écran de jeu
updateTextInput(session, "display_mode", value = "game")
})
# Sélection de la taille 8x8
observeEvent(input$select_size_8, {
updateTextInput(session, "grid_size", value = "8")
# Générer la grille initiale
game_data(generate_takuzu_grid(8, input$difficulty))
# Initialiser les valeurs des cellules
cell_values(game_data()$grid)
# Passer à l'écran de jeu
updateTextInput(session, "display_mode", value = "game")
})
# Sélection de la taille 10x10
observeEvent(input$select_size_10, {
updateTextInput(session, "grid_size", value = "10")
# Générer la grille initiale
game_data(generate_takuzu_grid(10, input$difficulty))
# Initialiser les valeurs des cellules
cell_values(game_data()$grid)
# Passer à l'écran de jeu
updateTextInput(session, "display_mode", value = "game")
})
# Génération dynamique de la grille UI
output$grid_ui <- renderUI({
req(game_data())  # S'assurer que game_data est initialisé
size <- grid_size()
data <- game_data()
values <- cell_values()
initial_filled <- data$initial_filled
fixed_color <- input$fixed_cell_color
# Ajuster dynamiquement le style de la grille selon la taille
grid_width <- min(size * 50, 500)  # Limiter la largeur maximale
# Style de la grille adapté à la taille
grid_style <- sprintf("
display: grid;
grid-template-columns: repeat(%d, 1fr);
gap: 5px;
margin: 20px auto;
width: %dpx;
", size, grid_width)
tags$div(
style = grid_style,
lapply(1:size, function(row) {
lapply(1:size, function(col) {
cell_id <- paste0("cell_", row, "_", col)
current_value <- values[row, col]
# Vérifier si cette cellule est initialement remplie
is_fixed <- initial_filled[row, col]
# Classe CSS différente pour les cellules fixes
cell_class <- if (is_fixed) {
"takuzu-cell takuzu-cell-fixed"
} else {
"takuzu-cell takuzu-cell-editable"
}
# Style pour les cellules fixes avec la couleur sélectionnée
cell_style <- if (is_fixed) {
sprintf("background-color: %s;", fixed_color)
} else {
""
}
# Ajuster la taille des cellules si la grille est grande
cell_size <- max(30, min(50, 400/size))
cell_style <- paste0(cell_style, sprintf("width: %dpx; height: %dpx; font-size: %dpx;",
cell_size, cell_size, cell_size * 0.5))
actionButton(
inputId = cell_id,
label = current_value,
class = cell_class,
style = cell_style
)
})
})
)
})
# Observer dynamique pour les clics sur les cellules
observe({
req(game_data())
size <- grid_size()
# Créer des observateurs pour chaque cellule selon la taille actuelle
lapply(1:size, function(row) {
lapply(1:size, function(col) {
cell_id <- paste0("cell_", row, "_", col)
observeEvent(input[[cell_id]], {
req(game_data())
data <- game_data()
initial_filled <- data$initial_filled
# Ne pas permettre la modification des cellules initialement remplies
if (row <= nrow(initial_filled) && col <= ncol(initial_filled) && !initial_filled[row, col]) {
values <- cell_values()
current_value <- values[row, col]
# Changement cyclique : "" → "0" → "1" → ""
new_value <- ifelse(current_value == "", "0",
ifelse(current_value == "0", "1", ""))
values[row, col] <- new_value
cell_values(values)
updateActionButton(session, cell_id, label = new_value)
}
}, ignoreInit = TRUE)
})
})
})
# Mettre à jour les styles des cellules lorsque la couleur change
observeEvent(input$fixed_cell_color, {
req(game_data())
size <- grid_size()
data <- game_data()
initial_filled <- data$initial_filled
fixed_color <- input$fixed_cell_color
# Parcourir toutes les cellules fixes et mettre à jour leur style
for (row in 1:size) {
for (col in 1:size) {
if (row <= nrow(initial_filled) && col <= ncol(initial_filled) && initial_filled[row, col]) {
cell_id <- paste0("cell_", row, "_", col)
runjs(sprintf(
"$('#%s').css('background-color', '%s');",
cell_id, fixed_color
))
}
}
}
})
# Vérification de la grille
observeEvent(input$check_btn, {
req(game_data())
size <- grid_size()
data <- game_data()
values <- cell_values()
# Débogage
print("Valeurs actuelles:")
print(values)
print("Solution attendue:")
print(data$solution)
# Vérifier que toutes les cellules sont remplies
if (any(values == "")) {
showModal(modalDialog(
title = "Grille incomplète",
HTML("<p style='color: black;'>Veuillez remplir toutes les cellules avant de vérifier.</p>"),
easyClose = TRUE,
footer = modalButton("OK")
))
return()
}
# Vérifier si la grille est valide selon les règles du Takuzu
correct <- all(values == data$solution)
if (correct) {
showModal(modalDialog(
title = "Félicitations !",
HTML("<h3 style='color: black; text-align: center;'>Bravo ! Vous avez résolu le puzzle correctement.</h3>"),
easyClose = TRUE,
footer = modalButton("Continuer")
))
} else {
showModal(modalDialog(
title = "Essayez encore",
HTML("<p style='color: black;'>Il y a des erreurs dans votre solution. Continuez à essayer !</p>"),
easyClose = TRUE,
footer = modalButton("OK")
))
}
})
# Nouvelle partie
observeEvent(input$new_game_btn, {
# Obtenir la taille et difficulté actuelles
size <- grid_size()
diff_level <- input$difficulty
# Générer une nouvelle grille avec la taille actuelle
new_data <- generate_takuzu_grid(size, diff_level)
game_data(new_data)
cell_values(new_data$grid)
# Afficher un message
showNotification(
"Nouvelle partie générée !",
type = "message",
duration = 3
)
})
}
# Lancer l'application
shinyApp(ui, server)
library(shiny); runApp('Application.R')
#' with no more than two identical numbers adjacent to each other, and no two rows or columns can be identical.
#'
#' @param n Integer. The size of the grid (n x n). Must be even. Default is 6.
#' @param difficulty Numeric between 0 and 1. Controls how many cells are initially empty. Default is 0.5.
#'
#' @return A list containing:
#'   \item{grid}{The puzzle grid with empty cells represented by ""}
#'   \item{solution}{The complete solution grid}
#'   \item{initial_filled}{A logical matrix indicating which cells were initially filled}
#' @export
generate_takuzu_grid <- function(n, difficulty) {
# Vérifie si un vecteur contient trois éléments identiques consécutifs
has_three_consecutive <- function(vec) {
# Vérifie si le vecteur a au moins 3 valeurs dans le vecteur à comparer
if (length(vec) < 3) return(FALSE)
# Pour i jusqu'à -2 car on observe les deux éléments suivants à chaque fois
for (i in 1:(length(vec)-2)) {
# Vérifie qu'il n'y ait pas de valeur manquante
if (!is.na(vec[i]) && !is.na(vec[i+1]) && !is.na(vec[i+2]) &&
# Cherche si trois valeurs de suite sont égales
vec[i] == vec[i+1] && vec[i+1] == vec[i+2]) {
# Si oui on retourne que c'est vrai et la fonction s'arrête
return(TRUE)
}
}
# Si on ne trouve pas trois valeurs de suite égales, on retourne false
return(FALSE)
}
# Vérifie si deux vecteurs sont identiques
are_vectors_equal <- function(vec1, vec2) {
# Vérifie si les deux vecteurs à comparer ont les mêmes longueurs
if (length(vec1) != length(vec2))
return(FALSE)
# Créé un vecteur logique avec des TRUE pour les positions où les deux vecteurs ont des valeurs non NA
non_na_positions <- !is.na(vec1) & !is.na(vec2)
# Vérifie s'il existe au moins une position où les deux vecteurs ont des valeurs non-NA à comparer
if (sum(non_na_positions) == 0)
return(FALSE)
# Compare les valeurs des deux vecteurs uniquement aux positions où ils ont tous deux des valeurs non-NA
return(all(vec1[non_na_positions] == vec2[non_na_positions]))
}
# Vérifie si un vecteur est présent dans une liste de vecteurs
is_vector_in_list <- function(vec, vec_list) {
# Applique la fonction à vec_list, en comparant chaque éléments avec ceux dans le vecteur de référence
sapply(vec_list, function(v) are_vectors_equal(vec, v)) |> any()
}
# Vérifie si un placement est valide
is_valid_placement <- function(grid, r, c, val) {
# Test de la règle des trois consécutifs
# Extrait la ligne r
row_vals <- grid[r, ]
# Lui attribue temporairement la valeur 'val' à la position c
row_vals[c] <- val
# Vérifie s'il y a trois chiffres consécutifs identiques
if (has_three_consecutive(row_vals))
return(FALSE)
# Extrait la colonne c
col_vals <- grid[, c]
# Lui attribue temporairement la valeur 'val' à la position r
col_vals[r] <- val
# Vérifie s'il y a trois chiffres consécutifs identiques
if (has_three_consecutive(col_vals))
return(FALSE)
# Vérification du nombre de 0 et 1 (pas plus de la moitié de 0 ou de 1)
# Vérification pour les lignes
if (sum(row_vals == 0, na.rm = TRUE) > n/2 ||
sum(row_vals == 1, na.rm = TRUE) > n/2)
return(FALSE)
# Vérification pour les colonnes
if (sum(col_vals == 0, na.rm = TRUE) > n/2 ||
sum(col_vals == 1, na.rm = TRUE) > n/2)
return(FALSE)
# Vérification des lignes identiques
# Si la ligne r (avec la nouvelle valeur) est complète (sans NA)
if (!any(is.na(row_vals))) {
# Crée une liste contenant toutes les autres lignes complètes
complete_rows <- lapply(1:n, function(i)
if(i != r && !any(is.na(grid[i, ]))) grid[i, ]
else NULL)
# Filtre pour ne garder que les lignes non-NULL
complete_rows <- complete_rows[!sapply(complete_rows, is.null)]
# Si la ligne r est identique à une autre ligne complète, le placement est invalide
if (length(complete_rows) > 0 && is_vector_in_list(row_vals, complete_rows))
return(FALSE)
}
# Vérification des colonnes identiques
# Si la colonne c (avec la nouvelle valeur) est complète (sans NA)
if (!any(is.na(col_vals))) {
# Crée une liste contenant toutes les autres colonnes complètes
complete_cols <- lapply(1:n, function(j)
if(j != c && !any(is.na(grid[, j]))) grid[, j]
else NULL)
# Filtre pour ne garder que les colonnes non-NULL
complete_cols <- complete_cols[!sapply(complete_cols, is.null)]
# Si la colonne c est identique à une autre colonne complète, le placement est invalide
if (length(complete_cols) > 0 && is_vector_in_list(col_vals, complete_cols))
return(FALSE)
}
return(TRUE)
}
# Génère une grille complète avec backtracking
generate_grid <- function() {
# Créé une grille vide de taille n x n remplie de valeurs NA
grid <- matrix(NA, nrow = n, ncol = n)
# Fonction qui travaille cellule par cellule pour compléter la grille
solve <- function(pos = 1) {
# Si on dépasse la dernière cellule, alors on a terminé
if (pos > n*n)
return(TRUE)
# Calcule les coordonnées correspondant à la position actuelle dans la grille
r <- ceiling(pos/n)
c <- (pos-1) %% n + 1
# Essaye de placer 0 et 1 dans un ordre aléatoire
for (val in sample(c(0, 1))) {
# Vérifie si placer val à la position (r,c) respecte toutes les règles
if (is_valid_placement(grid, r, c, val)) {
# Si le placement est valide, on assigne cette valeur à la cellule
grid[r, c] <<- val
# Appel récursif pour remplir la cellule suivante
if (solve(pos + 1))
# Si l'appel réussi, on retourne TRUE et on propage le succès
return(TRUE)
# Si l'appel échoue, on annule le placement en remettant NA et on essaie l'autre valeur
grid[r, c] <<- NA
}
}
# Si aucune des valeurs ne permet de continuer à remplir la grille, on indique l'échec de l'essai
return(FALSE)
}
# Lancer le processus de résolution
if (solve())
# Si ça réussi, on retourne la grille complète
return(grid)
# Sinon, on indique qu'on a pas pu compléter cette grille
return(NULL)
}
# Génère une grille (avec plusieurs tentatives si nécessaire)
# Initialiser un compteur d'essai
attempt <- 1
# Fixer un nombre maximum d'essai de 40
max_attempts <- 40
# Initialiser pour une grille non valide
complete_grid <- NULL
# Boucle qui continue tant qu'on n'a pas de grille valide ET qu'on n'a pas dépassé le nombre max d'essais
while (is.null(complete_grid) && attempt <= max_attempts) {
complete_grid <- generate_grid()
attempt <- attempt + 1
}
# Si au bout du nombre max d'essai on a pas réussi à générer, arrêter et mettre un message d'erreur
if (is.null(complete_grid)) {
stop("Impossible de générer une grille valide après plusieurs tentatives")
}
# Convertit la solution numérique en une matrice de caractères
solution <- matrix(as.character(complete_grid), nrow = n)
# Copie la grille solution pour pouvoir enlever des cellules
puzzle_grid <- solution
# Calcul combien de cellules retirer en fonction de la difficulté
cells_to_remove <- round(n * n * difficulty)
# Si des cellules doivent être retirées
if (cells_to_remove > 0) {
# Choisit aléatoirement les cellules à enlever
remove_indices <- sample(1:(n*n), cells_to_remove)
#  Remplace par des cellules vides
puzzle_grid[remove_indices] <- ""
}
# Matrice booléenne indiquant les cellules initialement remplies et les autres vides
initial_filled <- puzzle_grid != ""
# Retourner une liste avec : la grille correcte avec : les cases vides, la grill
return(list(
# La grille correcte avec les cases vides initiales
grid = puzzle_grid,
# La grille complète avec toutes les bonnes réponses
solution = solution,
# Matrice booléenne indiquant les cellules initialement remplies
initial_filled = initial_filled
))
}
runApp('Application.R')
runApp('Application.R')
runApp('Application.R')
runApp('Application.R')
runApp('Application.R')
#' Créer un module de minuteur pour les jeux Shiny
#'
#' Cette fonction crée un module Shiny pour gérer un minuteur
#' dans une application de jeu.
#'
#' @param id Identifiant unique pour le module
#' @return Une liste contenant les fonctions UI et server du module
#' @export
create_timer <- function(id) {
# UI du module
timer_ui <- function(id) {
ns <- NS(id)
div(class = "timer-container",
h3(id = ns("timer_display"), "Temps: 00:00"),
div(
actionButton(ns("start_timer"), "Démarrer", class = "btn-timer"),
actionButton(ns("pause_timer"), "Pause", class = "btn-timer"),
actionButton(ns("reset_timer"), "Réinitialiser", class = "btn-timer")
)
)
}
# Server du module
timer_server <- function(id, auto_start = FALSE, auto_reset = FALSE) {
moduleServer(id, function(input, output, session) {
# Valeurs réactives
timer_value <- reactiveVal(0)
timer_active <- reactiveVal(FALSE)
# Fonction pour formater le temps
format_time <- function(seconds) {
minutes <- floor(seconds / 60)
secs <- seconds %% 60
sprintf("%02d:%02d", minutes, secs)
}
# Mise à jour du timer
observe({
# N'exécuter que si le timer est actif
req(timer_active())
# Mettre à jour toutes les secondes
invalidateLater(1000)
# Incrémenter le temps
timer_value(timer_value() + 1)
# Formater et afficher le temps
formatted_time <- format_time(timer_value())
# Mettre à jour l'affichage
updateTextInput(session, "timer_display", value = paste("Temps:", formatted_time))
})
# Démarrer le minuteur
observeEvent(input$start_timer, {
timer_active(TRUE)
})
# Mettre en pause le minuteur
observeEvent(input$pause_timer, {
timer_active(FALSE)
})
# Réinitialiser le minuteur
observeEvent(input$reset_timer, {
timer_active(FALSE)
timer_value(0)
})
# Fonctions exposées pour contrôler le timer depuis l'extérieur
return(list(
start = function() { timer_active(TRUE) },
pause = function() { timer_active(FALSE) },
reset = function() {
timer_active(FALSE)
timer_value(0)
},
get_time = function() {
list(
seconds = timer_value(),
formatted = format_time(timer_value())
)
},
is_active = function() { timer_active() }
))
})
}
return(list(
ui = timer_ui(id),
server = timer_server
))
}
runApp('Application.R')
runApp('Application.R')
library(shiny); runApp('Application.R')
runApp('Application.R')
runApp('Application.R')
# Dans la console R
setwd("chemin/vers/dossier/parent/de/Grille2")  # Allez dans le dossier contenant le package
setwd("chemin/vers/dossier/parent/de/Grille2")
devtools::install("Grille2")
